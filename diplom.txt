Выбор программного обеспечения для разработки

// приложу ссылки на библиотеки у заголовков, вдруг понадобятся

Для разработки интерактивного веб-приложения, подразумевающего под собой взаимодействие пользователя со множеством элементов и компонентов страницы, стоит внимательно и осознанно подойти к выбору программного обеспечения, технологий и библиотек, используемых для создания приложения. В первую очередь стоит определить основной стек технологий, необходимых для первоначального запуска и работы приложения.

Первостепенно для выбора технологий для разработки стоит обратить внимание на функционал, который будет выполняться в приложении. Для разработки одностраничных веб-сайтов (лэндингов) хорошо подходят конструкторы сайтов, такие как: WordPress, Tilda, Wix и т.д., так как не требуют высоких навыков программирования, и имеют низкий порог вхождения. Данные сервисы представляют собой конструктор сайта с заготовленными блоками и компонентами, и возможностью их кастомизации. Но подобные сервисы имеют несколько критических, в нашем случае, минусов – конструкторы сайтов имеют ограниченный функционал и не позволяют полностью управлять логикой и взаимодействием компонентов, как это требуется для нашего веб-приложения. Так же для соответствия дизайну и дизайн системе в проекте должна присутствовать возможность полной настройки и создания компонентов самостоятельно, иначе консистентность и соответствие дизайны макетам будут нарушены. Поэтому стоит обратить внимание на другие технологии, такие как: HTML и CSS. HTML (Hyper Text Markup Language) - это язык разметки, используемый для создания и структурирования веб-страниц. Он состоит из серии тегов, которые определяют структуру и содержимое страницы, такие как заголовки, абзацы, изображения, ссылки и другие элементы. HTML-код интерпретируется браузером и отображается пользователю в виде веб-страницы. CSS (Cascading Style Sheets) — это язык таблиц стилей, который используется для оформления и внешнего оформления веб-страниц, созданных с помощью HTML. CSS определяет внешний вид элементов HTML, таких как цвета, шрифты, размеры, расположение и другие аспекты дизайна. Он позволяет разделять структуру и содержимое страницы от ее стилизации, что обеспечивает более гибкое и масштабируемое управление оформлением. CSS-правила применяются к элементам HTML с помощью селекторов, указывающих, на какие элементы должны быть применены определенные стили. Эти два инструмента прекрасно подходят, чтобы решить задачу полноценной настройки и кастомизации компонентов дизайн системы. HTML создает разметку, а CSS описывает для неё стили: расположение элементов, цвета, формы и так далее. Чтобы решить проблему ограничения функциональности, которая присутствует в конструкторах сайтов, обратим внимание на язык программирования JavaScript. Этот язык отвечает за всё взаимодействие и интерактив, которое происходит между пользователем и веб-приложением. JavaScript — это высокоуровневый интерпретируемый язык программирования, который используется для добавления интерактивности, динамического поведения и функциональности на веб-страницы. Он широко применяется для разработки клиентской части веб-приложений и взаимодействия с пользователем. JavaScript позволяет создавать и изменять содержимое веб-страницы, обрабатывать события (например, щелчки мыши и нажатия клавиш), выполнять асинхронные запросы к серверу, анимировать элементы, валидировать данные форм и многое другое. JavaScript поможет нам переходить по страницам, использовать технологию Drag&Drop (хватай и бросай) и много другого разного функционала, требуемого в приложении.

Один из критериев выбора технологий – анализ рынка. Для того, чтобы провести анализ рынка на предмет технологий в сфере frontend-разработки, используем любой веб-сайт, с возможностью просмотра и выбора вакансий труда, например hh.ru (https://hh.ru/). Проанализировав вакансии в сфере frontend-разработки можно сделать вывод о том, что преобладающее количество вакансий рассматривают возможность трудоустройства разработчиков, имеющих знания и опыт разработки приложений, с использованием таких технологий, как HTML, CSS, JavaScript, WordPress, Tilda и соответствующих для языка программирования JavaScript фреймворках: VueJS (30% вакансий в сфере frontend-разработки), ReactJS (60% вакансий) и Angular (10% вакансий). Значительное преимущество в базовых навыках имеют вакансии с HTML, CSS и JavaScript в качестве основы.

В ходе проектирования архитектуры приложения было принято решение использовать не чистый язык программирования JavaScript, язык разметки HTML и язык стилей CSS, а фреймворки на базе языка JS.

Использование фреймворков для разработки веб-приложений предоставляет следующие преимущества:

1.	Ускорение разработки: Фреймворки предоставляют готовую архитектуру, набор инструментов и решений, которые упрощают процесс разработки. Они предлагают готовые модули, библиотеки и функции, что позволяет разработчикам сосредоточиться на бизнес-логике приложения, а не на написании базового кода.

2.	Согласованность и структура: Фреймворки часто предлагают строгую структуру и правила разработки, что способствует согласованности кода внутри проекта. Это делает приложение более поддерживаемым, понятным и легко масштабируемым.

3.	Повторное использование кода: Фреймворки позволяют создавать модули, компоненты и шаблоны, которые можно повторно использовать в разных частях приложения или даже в разных проектах. Это ускоряет разработку и облегчает сопровождение кода.

4.	Улучшенная безопасность: Многие фреймворки имеют встроенные механизмы для обеспечения безопасности, такие как предотвращение атак XSS (межсайтовый скриптинг) и CSRF (межсайтовая подделка запроса).

5.	Большое сообщество и поддержка: Популярные фреймворки имеют активное сообщество разработчиков, которое предлагает поддержку, документацию, учебные ресурсы и сторонние библиотеки. Это облегчает процесс изучения и разработки, а также предоставляет доступ к лучшим практикам и современным технологиям.

Стоит учитывать, что использование фреймворков может иметь и некоторые недостатки, такие как изучение новых концепций и ограничение свободы действий, связанное с использованием предопределенных структур и решений. Выбор фреймворка должен быть основан на потребностях проекта и опыте, и так как у нашего приложения присутствует заготовленная дизайн система и планы по взаимодействию с серверной частью (бэкендом) – выбор фреймворка в качестве основной технологии для разработки – это хорошее решение.

В качестве фреймворка для разработки веб-приложения был выбран ReactJS (https://ru.legacy.reactjs.org/). ReactJS является одним из наиболее популярных фреймворков для разработки веб-приложений, и есть несколько причин, почему выбор остановился именно на ReactJS:

1.	Компонентная архитектура: ReactJS основан на компонентной модели, которая позволяет разбивать пользовательский интерфейс на небольшие, независимые и переиспользуемые компоненты. Это делает код более организованным, понятным, легко поддерживаемым и идеально сочетается с наличием дизайн системы, под которую можно создать и настроить нужным образом компоненты для дальнейшего переиспользования.

2.	Виртуальная DOM: ReactJS использует виртуальную DOM, что позволяет эффективно обновлять только необходимые части страницы при изменении данных. Это приводит к более быстрой отрисовке и улучшает производительность веб-приложений. Виртуальная DOM (Document Object Model) – это, проще говоря, копия реальной модели документа (веб-страницы). React создает её для того, чтобы отслеживать изменения которые произошли в ходе взаимодействия пользователя со страницей и выполнить сравнение виртуальной DOM и реальной, а замет обновить в реальной DOM только те элементы, которые в ходе сравнения были выявлены как измененные.

3.	Язык JSX: ReactJS предлагает JSX - расширение языка JavaScript, которое позволяет писать компоненты с использованием HTML-подобного синтаксиса. Это делает код более понятным и удобным для разработчиков.

 
(пример кода JSX)

4.	Однонаправленный поток данных: ReactJS поощряет структурирование приложения таким образом, чтобы данные передавались только в одном направлении, от родительских компонентов к дочерним компонентам. Этот подход делает управление состоянием приложения более предсказуемым и облегчает отслеживание изменений данных.

5.	Большое сообщество и экосистема: ReactJS имеет активное сообщество разработчиков, которое предлагает множество дополнительных библиотек, инструментов и ресурсов для упрощения разработки. Это облегчает изучение и ускоряет разработку проектов.

6.	React имеет не высокий порог вхождения новых разработчиков и обширную документацию и ресурсы: React имеет обширную и хорошо структурированную документацию, которая охватывает основные концепции, функции и методы. Кроме того, существуют множество учебных ресурсов, онлайн-курсов, видеоуроков и сообществ, которые помогают новым разработчикам изучить React и начать работу.

7.	Инструменты разработчика: React поддерживается широким набором инструментов, таких как React Developer Tools, которые облегчают отладку, инспекцию компонентов и отслеживание состояния приложения. Это помогает новым разработчикам быстрее разобраться с кодом и находить ошибки.

Существует также множество дополнительных инструментов и технологий для ускорения разработки. Одни из них – препроцессоры. Препроцессоры CSS — это инструменты, которые расширяют функциональность обычного CSS и позволяют разработчикам писать стилевые таблицы более эффективно и удобно. Они предоставляют дополнительные функции, такие как переменные, миксины, вложенные стили, операторы и другие возможности, которые не поддерживаются нативным (базовым) CSS.

Некоторые из популярных препроцессоров CSS:

1.	Sass (Syntactically Awesome Style Sheets): Sass предлагает мощные функции, такие как вложенные правила, миксины, наследование, операции с цветами и многое другое. Он использует синтаксис с расширением .scss и .sass.

2.	Less: Less также расширяет возможности CSS, предлагая переменные, миксины, операции с цветами и другие возможности. Он использует синтаксис с расширением .less.

3.	Stylus: Stylus предоставляет синтаксис с простыми и лаконичными правилами написания CSS. Он также поддерживает переменные, миксины и другие возможности.

Препроцессоры CSS помогают сделать код стилей более модульным, позволяют использовать повторяющиеся стили и облегчают его сопровождение и масштабирование. Они также облегчают разработку для различных устройств и браузеров, позволяя создавать динамические стили с использованием переменных и условных операторов. После написания кода на препроцессоре CSS он компилируется в обычный CSS, который затем используется на веб-страницах. Для разработки веб-приложения был выбран препроцессор SASS (https://sass-lang.com/), так как является одним из самых популярных и удобных, а его функционал полностью покрывает наши потребности. С помощью этого препроцессора разработка и написание стилей для компонентов будут значительно ускорены.

Так как в нашем приложении предусмотрен переход между разными страницами стоит обратить внимание на библиотеки для роутинга. ReactJS имеет возможности для того, чтобы “отрисовывать” компоненты динамически – то есть находясь на одной и той же страничке возможно отображение абсолютно разного контента. Поэтому была возможность сделать приложение по типу SPA. SPA (Single Page Application) — это тип веб-приложения, которое загружает одну HTML-страницу и динамически обновляет ее содержимое без перезагрузки страницы при взаимодействии пользователя. В SPA весь код и ресурсы (такие как стили, скрипты, изображения) загружаются один раз при первоначальной загрузке, и дальнейшая навигация и взаимодействие происходят через асинхронные запросы на сервер или манипуляции с DOM. Но так как страницы нашего приложения имеют разный контент, была выбрана структура многостраничного приложения, вместо single page application. Это поможет пользователю легче ориентироваться на сайте и переходить на нужную страницу прямо через адресную строку. Для реализации роутинга и перехода между страницами в своем проекте мы использовали библиотеку React Router DOM.

React Router DOM (https://reactrouter.com/en/main) предлагает такие положительные характеристики, как:

1.	Популярность и широкая поддержка: react-router-dom является одной из наиболее популярных и широко используемых библиотек для роутинга в React-приложениях. Она имеет активное сообщество разработчиков, что обеспечивает поддержку, обновления и регулярные исправления ошибок.

2.	Гибкость и мощные возможности: react-router-dom предоставляет гибкие и мощные инструменты для настройки и управления маршрутами в вашем приложении. Она позволяет определять маршруты с параметрами, вложенные маршруты, защищенные маршруты, а также предоставляет множество способов для перехода между страницами.


3.	Интеграция с React-экосистемой: react-router-dom разработана специально для работы с React и тесно интегрируется с другими библиотеками и инструментами React-экосистемы. Она хорошо сочетается с компонентным подходом React, позволяет использовать контекст и хуки React для управления состоянием маршрутизации.

4.	Хорошая документация и учебные ресурсы: Библиотека react-router-dom имеет хорошо структурированную документацию и обширное количество учебных ресурсов, таких как официальные руководства, примеры кода и сообщества разработчиков. Это облегчает изучение и использование библиотеки.

Все выбранные ранее технологии имеют декларативный подход. Декларативный подход — это парадигма программирования, в которой вы описываете желаемый результат или состояние, а не шаги, необходимые для достижения этого результата. Вместо явного указания шагов выполнения, вы объявляете, что должно произойти, и система сама заботится о реализации этого.

В контексте разработки веб-приложений, декларативный подход широко используется при работе с пользовательским интерфейсом. Вместо того, чтобы явно программировать каждое действие и изменение интерфейса, вы описываете, каким должен быть интерфейс в разных состояниях и событиях.

Примеры декларативного подхода в разработке веб-приложений:

HTML: HTML является декларативным языком разметки. Вы определяете структуру и содержимое веб-страницы, используя различные теги и атрибуты, а браузер заботится о рендеринге и отображении этой разметки.

CSS: CSS также использует декларативный подход. Вы описываете стили и внешний вид элементов веб-страницы, указывая селекторы, свойства и значения, и браузер применяет эти стили к соответствующим элементам.

React: React, фреймворк для разработки пользовательских интерфейсов, также поддерживает декларативный подход. Вы создаете компоненты, которые описывают, как должны выглядеть интерфейс в разных состояниях и событиях, а React обновляет интерфейс автоматически при изменении состояния компонента.

React Router DOM основана на декларативном подходе, который интегрируется хорошо с React и позволяет определять маршруты и переходы в виде компонентов. Это делает код более читабельным и понятным, а также облегчает разработку и поддержку приложения.


Декларативный подход упрощает разработку и поддержку кода, так как вам не нужно явно указывать все детали и шаги выполнения. Он позволяет сосредоточиться на описании желаемого состояния и результатов, делая код более читабельным, понятным и легким для сопровождения.

Одними из самых сложных, в плане реализации, элементов, являются карточки на странице веб-приложения. Все карточки на главной странице приложения поддерживают захват, перетаскивание, отпускание, нажатие и перекрытие. Перетаскивание элементов на веб-странице — это drag&drop. Для реализации подобного функционала понадобится библиотека, способная помочь в реализации функционала drag and drop, и выбор пал на React DND (https://react-dnd.github.io/react-dnd/about). Библиотека react-dnd является хорошим выбором для реализации функционала перетаскивания (drag and drop) по нескольким причинам:

1.	Простота использования: react-dnd предоставляет простой и интуитивно понятный API для реализации перетаскивания и сброса элементов. Она предоставляет компоненты высшего порядка (Higher Order Components, HOC) и крючки (hooks) для связи перетаскиваемых элементов с контейнерами и обработки событий перетаскивания.

2.	Гибкость и настраиваемость: react-dnd предлагает гибкую систему для определения различных типов перетаскиваемых элементов и контейнеров, а также возможность настраивать различные параметры и поведение перетаскивания, такие как ограничения перемещения, реакция на события мыши и т.д. Она поддерживает как простое перетаскивание элемента, так и более сложные функции, например, создание списков с возможностью перетаскивания элементов между ними.

3.	Совместимость с React: react-dnd является нативной библиотекой для React, что делает ее интеграцию в проект на React простой и естественной. Она хорошо сочетается с другими компонентами и библиотеками React, такими как Redux или React Router.

4.	Активное сообщество и поддержка: react-dnd имеет активное сообщество разработчиков, которое обеспечивает поддержку, обновления и исправление ошибок. Существует также обширная документация и руководства, а также множество примеров использования, что делает процесс изучения и использования библиотеки более легким.

5.	Популярность и практические применения: react-dnd является одной из наиболее популярных библиотек для реализации функционала перетаскивания в React-приложениях. Она успешно применяется во многих проектах и имеет хорошие отзывы от разработчиков.

В целом, react-dnd предлагает удобный и гибкий инструментарий для реализации функционала перетаскивания в React-приложениях. Она облегчает разработку и обеспечивает хороший пользовательский опыт при взаимодействии с элементами через перетаскивание.




Разработка веб-приложения

Для начала разработки приложения стоит определить структуру разработки.
На рисунке № представлена структура папок и файлов приложения:
 
1.	Папка node_modules является стандартной директорией, создаваемой в проекте при использовании менеджера пакетов в Node.js, такого как npm (Node Package Manager) или Yarn. Она содержит все зависимости (пакеты) проекта, которые были установлены с помощью менеджера пакетов. Когда вы устанавливаете сторонние пакеты, указывая их в файле package.json или выполняя команду установки через менеджер пакетов, они загружаются из центрального репозитория и помещаются в папку node_modules. Зависимости могут быть как основными пакетами, необходимыми для запуска вашего приложения (например, React или Express), так и дополнительными пакетами, предоставляющими различные функциональные возможности или инструменты. Папка node_modules обычно содержит множество подпапок, каждая из которых представляет отдельный пакет. Каждый пакет в свою очередь может содержать свою структуру файлов и зависимости.
2.	Папка public предназначена для хранения файлов, необходимых после сборки приложения, например медиафайлы или иконки, которые подгружаются после сборки приложения. А также в ней расположен главный HTML файл, в который после сборки JavaScript попадает вся сгенерированная HTML разметка.
3.	В папке src содержатся все компоненты, используемые медиафайлы и другие данные, написанные разработчиком приложения, в том числе папка scr имеет логические подразделы:
- assets: весь медиаконтент и отображаемые на странице картинки
- components: компоненты, которые единоразово используются в приложении или являются локальными
- data: файлы с массивами данных карточек с разделением на подкатегории
- hooks: экспорт карточек, вынесенный в отдельные файлы, чтобы не “захламлять” компоненты
- pages: компоненты страниц, оборачивающие в себя составные, более мелкие компоненты
- shared: переиспользуемые компоненты приложения
Также в папке src находится входной файл приложения index.js и главный файл App.jsx и сопутствующие им файлы стилей.
4.	Файлы package.json и package-lock.json, содержащие основную информацию о приложении и установленных зависимостях, необходимых для его работы или разработки (подкатегория “devDependencies”).
5.	Файл .gitignore, необходимый для указания папок и файлов, которые не нtобходимо исключить из списка выгрузки в git репозиторий.
6.	Файл README.md с описанием того, как запустить приложение для разработки или сборки “продакшн” версии.

В данном приложении используется компонентный подход для реализации страниц и компонентов на странице. Компонентный подход — это методология разработки программного обеспечения, в которой приложение разбивается на небольшие самодостаточные модули, называемые компонентами. Компонент представляет собой независимую и переиспользуемую единицу функциональности, которая может быть использована на разных страницах приложения. Каждый компонент имеет свою собственную логику и внешний вид, а также может взаимодействовать с другими компонентами. Компоненты могут быть разного типа, в зависимости от их функциональности. Данное веб-приложение имеет компоненты для отображения заголовка страницы, навигационного меню, формы ввода данных, списка элементов и так далее.

При использовании компонентного подхода каждая страница приложения представляет собой композицию различных компонентов. Разработчики могут создавать новые компоненты или использовать уже существующие, которые были разработаны ранее. Компоненты могут быть вложены друг в друга для создания сложных пользовательских интерфейсов. Каждый компонент имеет свои собственные свойства (параметры), которые могут быть переданы ему извне. Это позволяет настраивать поведение и внешний вид компонента в зависимости от контекста его использования. Компоненты также могут взаимодействовать друг с другом путем передачи данных или событий. Например, компонент формы может отправлять данные другому компоненту для их обработки или отображения.

Точкой входа приложения является файл index.js. Данный файл выполняет следующие действия:

Импортируются необходимые зависимости:

- React из библиотеки "react";
- ReactDOM из "react-dom/client";
- index.scss, который содержит стили для данного приложения;
- App из "./App.jsx";
- BrowserRouter из "react-router-dom";
- DndProvider и HTML5Backend из "react-dnd".

Создается корневой элемент для рендеринга приложения с помощью ReactDOM.createRoot. Этот метод используется в React версии 18 и выше для оптимизации рендеринга.
Выполняется рендеринг компонентов с использованием корневого элемента. Компоненты обернуты в <React.StrictMode>, которая предупреждает о потенциальных проблемах в коде и рекомендует исправления для улучшения производительности и обнаружения проблем.
<BrowserRouter> предоставляет навигацию с использованием HTML5 History API и позволяет маршрутизировать компоненты на основе URL-адреса.
<DndProvider> и HTML5Backend предоставляют функциональность перетаскивания и сбрасывания элементов в приложении. DndProvider является контейнером для компонентов, которые поддерживают перетаскивание и сбрасывание, а HTML5Backend является специфичным для браузера бэкендом для этой функциональности.
Внутри <BrowserRouter> и <DndProvider> происходит рендеринг компонента <App />, который является главным компонентом приложения на React.

Таким образом, данный файл настраивает основные зависимости и производит инициализацию приложения, обеспечивая возможность маршрутизации и поддержки перетаскивания и сбрасывания элементов для библиотек React Router DOM и React DnD.

В данном приложении главным компонентом является компонент App. Этот компонент определяет структуру и маршрутизацию приложения.

В начале кода импортируются необходимые зависимости из библиотеки react-router-dom и компоненты страниц, которые будут использоваться в маршрутизации. Затем внутри функции App определены два состояния с помощью хука useState: isLogged отвечает за информацию о том, авторизован пользователь или нет, и изначально установлен в false. loginError используется для отображения сообщения об ошибке входа в систему и изначально установлен в false.

Хуки в React предоставляют возможность использовать состояние и другие возможности React в функциональных компонентах. Они были представлены в React версии 16.8 и позволяют разработчикам писать более компактный и понятный код, избегая классовых компонентов. Хуки предоставляют специальные функции, такие как useState, useEffect, useContext и другие, которые могут быть вызваны внутри функционального компонента.

useState является одним из наиболее часто используемых хуков в React. Он позволяет добавлять и использовать состояние внутри функциональных компонентов. useState возвращает массив с двумя элементами: текущим значением состояния и функцией, которая позволяет изменить это состояние. Функция для изменения состояния обычно называется set + имя состояния (например, setCount для состояния count).

При использовании useState в компоненте, React сохраняет значение состояния между рендерами компонента и обновляет его при вызове соответствующей функции изменения состояния. При изменении состояния React “перерисует” компонент, чтобы отразить новое значение состояния. Хук useState позволяет функциональным компонентам иметь свое собственное внутреннее состояние, делая их более интерактивными и динамичными.

Далее определена функция login, которая принимает данные в качестве аргумента. Функция проверяет, совпадают ли значения полей login и password с ожидаемыми значениями. Если значения совпадают, то устанавливается состояние isLogged в true, что означает успешный вход в систему. Если значения не совпадают, устанавливается состояние loginError в true, для отображения на несколько секунд ошибки и через 3 секунды оно снова устанавливается в false. Это позволяет отображать сообщение об ошибке входа в систему в течение 3 секунд.

Возвращаемое значение функции App содержит условный оператор. Если isLogged равно true, то отображается компонент <Routes>, который определяет маршрутизацию внутри приложения. Внутри <Routes> определены различные пути (<Route>) и соответствующие им компоненты страниц. Например, путь '/' соответствует компоненту <Main />, путь '/profile' соответствует компоненту <Profile /> и так далее. Если isLogged равно false, то отображается компонент <Login> с передачей ему функции login и состояния loginError в качестве пропсов. Таким образом, в зависимости от значения isLogged, приложение либо отображает основное содержимое с маршрутизацией, либо компонент входа в систему.

Данный код экспортирует компонент Main, который представляет собой главную страницу приложения. Основные действия, выполняемые в этом коде:

1.	Импортируются необходимые зависимости, такие как различные компоненты и стили.
2.	Создается контекст SelectedCardsContext с помощью функции createContext(). Контекст используется для передачи данных вниз по дереву компонентов без явной передачи через пропсы.
3.	Внутри компонента Main определены состояния с помощью хука useState(). Эти состояния включают searchText (текст для поиска), cardList (список карточек), selectedCards (выбранные карточки) и isHelpActive (флаг активации помощи).
4.	Используется хук useRef() для создания счетчика uniqueIdCounter, который будет использоваться для создания уникальных идентификаторов для выбранных карточек.
5.	Определена функция selectCard, которая вызывается при выборе карточки. Она создает копию списка карточек, находит выбранную карточку и присваивает ей уникальный идентификатор. Затем она обновляет состояние selectedCards, добавляя выбранную карточку в массив.
6.	Используется хук useEffect(), чтобы реагировать на изменения searchText. При каждом изменении searchText происходит фильтрация списка карточек allCards на основе введенного текста, и результаты фильтрации сохраняются в состояние cardList.
7.	Компонент Main возвращает JSX-разметку, которая представляет собой структуру главной страницы приложения. Внутри контекста SelectedCardsContext.Provider содержится весь контент страницы, включая заголовок, блоки с карточками, поиск, выпадающие списки и подвал.

Компоненты возвращаются в нужных местах с передачей соответствующих данных и функций через пропсы. Код создает основной компонент для главной страницы приложения, определяет состояния, обрабатывает события выбора карточек и обновления поискового текста, и возвращает структуру JSX-разметки для отображения на странице.

Главной функцией данного компонента является функция selectCard. Эта функция используется во всех карточках и отвечает за добавление карточки в список выбранных, для последующего отображения в поле выбранных карточек. Функция selectCard выполняет выбор карточки на основе предоставленного идентификатора, создает уникальный идентификатор для выбранной карточки и обновляет состояние selectedCards, добавляя выбранную карточку в массив. Происходит это следующим образом:
1.	Создается функция обратного вызова selectCard с использованием хука useCallback. useCallback используется для оптимизации производительности, чтобы сохранить ссылку на функцию между рендерами только в том случае, если изменяются зависимости, указанные в массиве зависимостей (в данном случае cardList и uniqueIdCounter).

2.	Когда функция selectCard вызывается, она получает объект с идентификатором (id) в качестве параметра.

3.	Создается копия списка cardList с помощью метода map(). Копирование выполняется с использованием оператора spread ({...obj}), чтобы создать новый объект и избежать мутации исходных данных.

4.	Фильтруется копия списка copyCards, чтобы найти элемент с заданным идентификатором (id). Функция filter() возвращает новый массив, содержащий элементы, для которых условие el.id === id выполняется. Таким образом, foundItem будет содержать первый найденный элемент, удовлетворяющий условию.

5.	Генерируется уникальный идентификатор (uniqueId) с помощью переменной uniqueIdCounter. Значение переменной увеличивается на 1 с помощью uniqueIdCounter.current++.

6.	Присваивается уникальный идентификатор к найденному элементу foundItem. Идентификатор состоит из исходного id и uniqueId, объединенных с помощью дефиса (-). Например, если исходный id равен "card1", а uniqueId равен 0, то новый идентификатор будет "card1-0".

7.	Обновляется состояние selectedCards с использованием функции setSelectedCards. В новом состоянии добавляется foundItem, используя оператор spread (...prevSelectedCards) для создания нового массива с предыдущими выбранными карточками и добавленной новой карточкой.

Для передачи функции selectCard в контекст SelectedCardsContext, который определен как createContext() в данном модуле, используется компонент SelectedCardsContext.Provider. Вот как функция selectCard передается в контекст:

1.	Внутри компонента Main обертка <SelectedCardsContext.Provider> оборачивает все дочерние компоненты, чтобы они имели доступ к значению контекста.

2.	В атрибуте value компонента <SelectedCardsContext.Provider> передается массив значений, которые будут доступны внутри контекста. В данном случае массив содержит три элемента: selectedCards, setSelectedCards и selectCard. selectedCards — это состояние, содержащее массив выбранных карточек. setSelectedCards — это функция, используемая для обновления состояния selectedCards. Эта функция будет доступна в компонентах, подписанных на контекст, чтобы они могли изменять состояние выбранных карточек. selectCard — это функция, которая передается в контекст и будет также доступна в компонентах, подписанных на контекст. Эта функция выполняет действия при выборе карточки, как было описано ранее.

3.	Когда значение контекста обновляется, все компоненты, подписанные на контекст, которые используют useContext(SelectedCardsContext) или SelectedCardsContext.Consumer, получают новые значения и “перерендериваются” при необходимости, чтобы отразить обновленное состояние и функции.

Таким образом, функция selectCard, вместе с другими значениями, передается в контекст SelectedCardsContext с помощью компонента <SelectedCardsContext.Provider>. Это позволяет другим компонентам внутри контекста получать доступ к этой функции и использовать ее для выполнения выбора карточек.

Для фильтрации карточек, с помощью поиска используется хук useEffect для отслеживания изменений значения searchText и выполнения определенных действий при каждом изменении.

1.	Когда компонент Main “рендерится”, хук useEffect регистрирует функцию-эффект, которая будет выполнена после каждого обновления компонента.

2.	Функция - эффект начинается с создания переменной filteredCards. filteredCards создается путем фильтрации массива allCards. Каждый элемент card в массиве allCards проверяется с помощью функции обратного вызова (card) => card.title.toLowerCase().indexOf(searchText.toLowerCase()) !== -1.

3.	Внутри функции обратного вызова происходит проверка на соответствие условию: значение title текущей карточки, приведенное к нижнему регистру, должно содержать значение searchText (приведенное также к нижнему регистру). Если условие выполняется (т.е., подстрока searchText найдена в title), то элемент card проходит фильтрацию и будет включен в filteredCards.

4.	Полученный отфильтрованный массив filteredCards устанавливается в состояние cardList с помощью функции setCardList. Таким образом, значение cardList будет обновлено и отфильтрованные карточки будут отображаться в компоненте.

5.	Зависимость массива searchText передается во второй аргумент useEffect, чтобы эффект был вызван только в случае изменения searchText. Если searchText не изменится, функция-эффект не будет вызываться повторно.

В результате этот код обеспечивает фильтрацию списка карточек (allCards) на основе значения searchText и обновление состояния cardList с отфильтрованными результатами. Это позволяет динамически обновлять отображаемые карточки на основе поискового запроса.

Данный компонент использует хук useDrop из библиотеки react-dnd для реализации функциональности перетаскивания (drag and drop).

1.	При помощи деструктуризации создаются две переменные isOver и drop. isOver будет содержать значение свойства isOver из объекта collect, а drop будет содержать функцию-обратный вызов, которая будет вызвана при событии "drop" (отпускании перетаскиваемого элемента).

2.	Функция-обратный вызов передается в хук useDrop в виде аргумента. В данном случае, используется стрелочная функция, которая возвращает объект с опциями для useDrop.

3.	В объекте опций указываются следующие свойства:
accept: "div": Устанавливает тип элемента, который может быть перетащен и принят в данную зону. В данном случае, принимаются элементы с типом "div".
drop: (id) => selectCard(id): Определяет функцию, которая будет вызвана при событии "drop". Функция принимает id перетаскиваемого элемента и вызывает функцию selectCard с переданным id.
collect: (monitor) => ({ isOver: !!monitor.isOver() }): Определяет функцию, которая собирает информацию о текущем состоянии перетаскивания. В данном случае, функция collect принимает объект monitor, который предоставляет информацию о состоянии перетаскивания, и возвращает объект с единственным свойством isOver, которое указывает, находится ли перетаскиваемый элемент над зоной (true - находится, false - не находится).
Результат хука useDrop деструктурируется в массив, где первый элемент ({ isOver }) присваивается переменной isOver, а второй элемент (drop) присваивается переменной drop.

Этот код создает функцию drop, которая используется для определения зоны, в которую можно перетащить элементы определенного типа (div), и определяет действия, которые должны быть выполнены при отпускании перетаскиваемого элемента в эту зону. Также, код собирает информацию о состоянии перетаскивания, такой как нахождение элемента над зоной, и делает ее доступной через переменную isOver.

А в компоненте Card (листинг №) используется хук useDrag для реализации функциональности “хватания” элемента. Он создает функцию drag, которая инициирует перетаскивание элемента и собирает информацию о состоянии перетаскивания в переменной isDragging.

Так же для каждой карточки существует слушатель события нажатия и определены функции для добавления карточки по нажатию и её удалению из списка карточек:

Функция deleteCard принимает cardId в качестве параметра и удаляет карточку с соответствующим cardId из массива selectedCards, если isDeletable равно true. Если isDeletable равно false, функция ничего не делает.

Функция scrollToTop выполняет плавную прокрутку страницы к верхней части блока с идентификатором "card-block". Она использует метод scrollIntoView для прокрутки элемента в видимую область с плавной анимацией, если элемент с указанным идентификатором существует.

Функция handleClick вызывается при клике на карточку. Если isDeletable равно true, вызывается функция deleteCard с card.id в качестве аргумента для удаления карточки. Если isDeletable равно false, вызывается функция selectCard (которая является частью контекста SelectedCardsContext) с card в качестве аргумента для выбора карточки. Затем переменная showNotification устанавливается в true, что отображает уведомление. Через 5 секунд уведомление скрывается путем установки переменной showNotification в false с помощью функции setTimeout.
